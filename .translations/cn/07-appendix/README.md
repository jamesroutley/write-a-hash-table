# 附录: 碰撞冲突的其它处理方案

在哈希表的冲突问题中，有两个最为常用的方法，分别是：

- 拉链法
- 开放寻址法

### 拉链法

拉链法，每个哈希元素都指向一个链表，当发生碰撞时候，把冲突的元素直接新增到链表中，方法如下：

- 插入：先通过哈希函数返回存储位置的索引值。如果当前位置还没被占用，则直接把元素添加到此位置。如果当前位置已经被占用了，则添加到链表的末端
- 查询：通过索引值定位到待查找元素的位置，然后遍历当前位置的链表，如果找到则返回，否则，返回 `NULL`
- 删除：和查找也是同样的道理，先找到目标元素，如果命中，则把当前元素从链表中删除，如果当前链表只有一个元素，则设置索引位置为 `NULL` 即可

拉链法的实现虽然很简单，但是空间效率太低了。因为哈希表的每个位置都需要存储一个指向链表的指针，
然而指针是会消耗内存的，实际上可以利用这些内存来存储更多的元素

### 开放地址

开放地址可以解决拉链法所带来的空间浪费问题。当冲突发生后，冲突的元素应该被放置在哈希表其它空余的位置上。
但是这个位置当然不是随意选取，如果随意选取的话，在查找的时候就无法查找到目标元素了。所以需要制定一套策略，供插入，查询使用

#### 线性探测 

线性探测，当发生冲突的时候，顺序查看哈表表中的下一个位置，直至找到一个空的位置或遍历全表，哈希函数如下：

- 插入：找到对应 key 的索引值，如果命中的位置为空，则把元素添加到这个位置。否则，查看冲突索引值的下个位置，直到找到一个空的位置去插入目标元素
- 查询：通过索引值定位到相应的位置，并通过比较两个 key 的值来确定待查找的元素，如果命中，则返回，否则，递增索引，重复上个过程
- 删除：同样的通过查询函数定位到目标位置，然后删除目标元素，但是仔细想想，直接删除该位置的元素将会导致在此位置之后的元素无法被查找，因此，需要将哈希表中被删除键的右侧的所有元素重新插入到散列表

线性探测提供了良好的[局部性原理](https://en.wikipedia.org/wiki/Locality_of_reference)，但是会遇到键簇（一组连续的条目）的问题，
使得探测的时间成本大大增加，因为每次发生冲突后可能需要遍历很长的一段距离才能找到可用的位置

#### 二次探查

此方法与线性探测类似，不同的一点在于发生冲突后，不是直接查找下一个索引位置，而是通过具有以下规律的序列来定位下个位置的索引值：`i, i + 1, i + 4, i + 9, i + 16, ...`，
其中 `i` 为发生冲突后的索引值。哈希函数如下：

- 插入：通过索引值以及序列查询到可用的位置，并将待添加的元素添加到此处
- 查询：通过索引值定位到相应的位置，并通过比较两个 key 的值来确定待查找的元素，如果命中，则返回，否则，通过序列函数计算下一个索引值，重复以上过程
- 删除：我们无法判断我们要删除的元素是否是冲突集的一部分，因此我们无法直接删除该元素而是使用标记的方法来实现删除操作

通过以上策略，二次探查比较好的缓解了线性探测的长键簇问题

#### 再哈希

二次探查仍然可能存在长键簇带来的问题，而再哈希法正是为了解决此问题。为此，
当发生冲突的时候，我们将使用第二个哈希函数作为新索引值，且索引值应该是均匀分布的。
在大多数的哈希表的实现上都使用再哈希法来解决冲突问题，同时，也是我们本教程所使用的方法


