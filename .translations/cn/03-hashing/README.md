# 哈希值函数

在这一节中，将编写哈希值函数来计算哈希索引值

哈希值函数应当满足以下要求：

- 输入一个字符串，返回一个 `0` - `m` 的整型数字， `m` 不大于哈希的长度，即上一节中 `ht_hash_table` 的 `size`

- 索引值结果必须均匀分布，如果计算的索引值分布不均匀，会导致大多数键都落在同一索引，且在哈希表插入过程中将会产生大量[冲突](#不符合预期的问题数据)，冲突将会在很大程度上降低哈希表的性能

## 算法

我们将使用字符串来计算哈希值，下面是该算法的伪代码

```
function hash(string, a, num_buckets):
    hash = 0
    string_len = length(string)
    for i = 0, 1, ..., string_len:
        hash += (a ** (string_len - (i+1))) * char_code(string[i])
    hash = hash % num_buckets
    return hash
```

从上面的伪代码可以看出，要生成一个哈希值，我们需要做以下两步操作：

1. 把字符串转换为整型
2. 因转换后的数字可能远大于哈希表的长度，所以我们需要通过 `mod` 取余数来保证生成的哈希值不大于哈希表长度 `m`

变量 `a` 是一个大于字母表大小的素数，因为本文的哈希值函数仅支持字符类型，而字符串的 ASCII 大小为 128，所以 `a` 的大小应是大于 128 的素数

`char_code` 则是将单字符转换为整数的方法

根据上面的描述，可以举例演示计算过程：

```
hash("cat", 151, 53)

hash = (151**2 * 99 + 151**1 * 97 + 151**0 * 116) % 53
hash = (2257299 + 14647 + 116) % 53
hash = (2272062) % 53
hash = 5
```

通过改变变量 `a` 的值，我们可以得到不同的哈希值

```
hash("cat", 163, 53) = 3
```

## 代码实现

```c
// hash_table.c
static int ht_hash(const char* s, const int a, const int m) {
    long hash = 0;
    const int len_s = strlen(s);
    for (int i = 0; i < len_s; i++) {
        hash += (long)pow(a, len_s - (i+1)) * s[i];
        hash = hash % m;
    }
    return (int)hash;
}
```

## 不符合预期的问题数据

理想的哈希值函数无论输入的参数是什么，其结果都是均匀分布的。然而，无论怎么优化哈希值函数，都很难生成唯一的哈希值，肯定会出现 `不符合预期` 的键，这些键生成的哈希值往往会与其它键所生成哈希值一致

这类问题数据集的存在，意味着没有完美的哈希值函数可以生成唯一的哈希值。所以我们所能做的就是想办法处理出现问题的数据

问题数据同时也存在安全性问题。如果某些恶意用户通过不断提供冲突的键给程序，那么当查询的时候就会比预期时间 `O(1)` 花费更多的时间 `O(n)` 才能找到目标值。这可以用作针对以哈希表（例如DNS和某些Web服务）为基础实现的程序进行 DDOS

下一节: [处理哈希冲突](../04-collisions)
[目录](/.translations/cn/README.md#目录)
